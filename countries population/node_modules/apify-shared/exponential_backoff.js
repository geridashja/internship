"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.retryWithExpBackoff = exports.RetryableError = void 0;

var _underscore = _interopRequireDefault(require("underscore"));

var _log = _interopRequireDefault(require("./log"));

var _utilities = require("./utilities");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class RetryableError extends Error {
  constructor(originalError, ...args) {
    super(...args);
    this.error = originalError;
  }

}

exports.RetryableError = RetryableError;

const retryWithExpBackoff = async (params = {}) => {
  const {
    func,
    expBackoffMillis,
    expBackoffMaxRepeats
  } = params;

  if (typeof func !== 'function') {
    throw new Error('Parameter "func" should be a function.');
  }

  if (typeof expBackoffMillis !== 'number') {
    throw new Error('Parameter "expBackoffMillis" should be a number.');
  }

  if (typeof expBackoffMaxRepeats !== 'number') {
    throw new Error('Parameter "expBackoffMaxRepeats" should be a number.');
  }

  for (let i = 0;; i++) {
    let error;

    try {
      return await func();
    } catch (e) {
      error = e;
    }

    if (!(error instanceof RetryableError)) {
      throw error;
    }

    if (i >= expBackoffMaxRepeats - 1) {
      throw error.error;
    }

    const waitMillis = expBackoffMillis * 2 ** i;

    const randomizedWaitMillis = _underscore.default.random(waitMillis, waitMillis * 2);

    if (i === Math.round(expBackoffMaxRepeats / 2)) {
      _log.default.warning(`Retry failed ${i} times and will be repeated in ${randomizedWaitMillis}ms`, {
        originalError: error.error.message,
        errorDetails: error.error.details
      });
    }

    await (0, _utilities.delayPromise)(randomizedWaitMillis);
  }
};

exports.retryWithExpBackoff = retryWithExpBackoff;